"""
Script for parsing ".xrdml" files, generated by the XRD equipment at DTU Physics.

There are two parts of this script: 
    The definition of the parser-functions.
    An example of the use of the functions
"""
import numpy as np
import re
import pandas as pd
from datetime import date

def _ytext(y_min, XRD_plot_fig_shift_add):
    """
    This function determines the y-coordinate for the label text
    inserted in the XRD plots.
    """
    return y_min-XRD_plot_fig_shift_add*0.05 
    
def convert_x_range_to_str(x1_lim, x2_lim):
    
    " Converts XRD x1_lim and x2_lim into a nice string to attach to "
    " the file name of the plot. "

    return ', x_range.' + str(x1_lim) + '.' + str(x2_lim) + ','

def get_plot_title(wanted_exps, wanted_refs):
    
    date_str = str(date.today())
    wanted_exps_str = ' ' + ' '.join([str(exp.split('_', 1)[0]) for exp in wanted_exps])
    wanted_ref_str = ', ref. ' + ' '.join([str(exp) for exp in wanted_refs])
    #', Pd RT, ZnO(TiO2), Si100'
    print(wanted_exps_str)
    return date_str + wanted_exps_str + wanted_ref_str

#wave_length of source
def read_xrdml_wavelength(path):
    raw_file = open(path)
    lines = raw_file.readlines()
    for index, line in enumerate(lines):
        if line.find('<usedWavelength intended="K-Alpha 1">') != -1:
            kAlpha1 = [float(value) for value in re.findall(r'\d+\.\d+',lines[index+1])]
            kAlpha2 = [float(value) for value in re.findall(r'\d+\.\d+',lines[index+2])]
            ratio_kA2_over_kA1 = [float(value) for value in re.findall(r'\d+\.\d+',lines[index+4])]
            wavelength = (ratio_kA2_over_kA1[0]*kAlpha2[0]+kAlpha1[0])/(ratio_kA2_over_kA1[0]+1)
            break
    return wavelength

#read spectrum
def read_xrdml_spectrum(path):
    file = open(path)
    lines = file.readlines()
    
    for index, line in enumerate(lines):
        if line.find('<positions axis="2Theta" unit="deg">') != -1:
            start_angle = [float(value) for value in re.findall(r'\d+\.\d+',lines[index+1])]
            end_angle = [float(value) for value in re.findall(r'\d+\.\d+',lines[index+2])]
        
        if line.find('intensities') != -1:
            spectrum = [float(value) for value in re.findall(r'\d+',lines[index])]
            spectrum = np.array(spectrum)
    
    spectrum = normalize_spectrum(spectrum)
    
    angle_step = (end_angle[0]-start_angle[0])/len(spectrum)
    angles = np.arange(start_angle[0],end_angle[0],angle_step)
    return angles, spectrum

#Bragg's law, for angles to inverse length
def inverse_length(angles,wavelength):
    angles = np.pi*np.array(angles)/180
    return 2*np.sin(angles/2)/wavelength

# reads reference spectrum (csv file)
def read_ref_spectrum(path):
    file = pd.read_csv(path, delimiter = ',',names = ['angles', 'spectrum'], header = None)    
    angles = file['angles']
    spectrum = file['spectrum']
    spectrum = normalize_spectrum(spectrum)
    return angles, spectrum

def read_exp_spectrum(path):
    #file = pd.read_csv(path, delimiter = ',',skiprows=range(0,26), names = ['Angle', 'Intensity'], header = 1)  powder
    file = pd.read_csv(path, delimiter = ',',skiprows=range(0,28), names = ['Angle', 'Intensity'], header = 1)
    angles = file['Angle']
    spectrum = file['Intensity']

    spectrum = normalize_spectrum(spectrum)
    return angles, spectrum

# Normalize all spectra by it's most intensive peak
def normalize_spectrum(spectrum):
    
    intensity_max = np.max(spectrum) 
    spectrum = np.divide(spectrum, intensity_max)

    return spectrum

# find Si shift
def calc_shift_spectrum(path):
    file = pd.read_csv(path, delimiter = ',',skiprows=range(0,26), names = ['Angle', 'Intensity'], header = 1)    
    intensity_max = np.max(file['Intensity'])  
    row = file.loc[file['Intensity'] == intensity_max]
    #print(row)
    angle_max = row['Angle']
    #print(angle_max)
    return angle_max
            
    
    

"""
example
"""
import matplotlib as mpl
from matplotlib import pyplot as plt
#plt.style.use('classic')

def plot_XRD(reffiles, files, labels, ref_labels, x_range, w, plt_title):
    #fonts for matplotlib
    font = {'family' : 'Palatino Linotype',
            #'weight' : 'bold',
            'size'   : 16}
    mpl.rc('font', **font)
    
    
    fig_shift = 0
    
    fig, rainbow = plt.subplots() #rainbow is just the call-name of the figure
            
    # plot experimental spectra
    for file,n in zip(files,range(0,len(files))):
            spectrum = read_xrdml_spectrum(file)
            rainbow.plot(spectrum[0],np.subtract(spectrum[1],fig_shift),label=labels[n])
            fig_shift += 0.8
    
    # plot reference spectra        
    for file,n in zip(reffiles,range(0,len(reffiles))):
            spectrum = read_ref_spectrum(file)
            rainbow.plot(spectrum[0],np.subtract(spectrum[1],fig_shift),label=ref_labels[n])
            fig_shift += 0.8
            #print(n)
    
        
    rainbow.set_xlabel(r'2$\theta$ / $^\circ$')
    rainbow.set_ylabel('Intensity / a.u.')
    #rainbow.tick_params('y')
    #rainbow.axes.set_title('A fishy title')
    #rainbow.tick_params(left= False)
    #rainbow.legend(loc='upper right', fontsize =  12)
    #rainbow.axes.set_xlim(range)
    #rainbow.yaxis.set_ticklabels([])
    rainbow.get_yaxis().set_ticks([])
    rainbow.xaxis.set_minor_locator(plt.MultipleLocator(1))
    rainbow.tick_params(which = 'minor', direction = 'in')

# necessary for the small plot(?)    
#    # Shrink current axis by 20%
#    box = rainbow.get_position()
#    rainbow.set_position([box.x0, box.y0, box.width * w, box.height])

    
    ## Put a legend to the right of the current axis
    rainbow.legend(loc='center left', bbox_to_anchor=(1, 0.5))
    #rainbow.legend(loc='upper right')
    
    rainbow.set_xlim(x_range[0],x_range[1])
    
    #plt_title = 'Python_spectra/20190121/' + plt_title 
    plt_title = 'Python_spectra/20190121/' + plt_title 
    
    plt.savefig(plt_title,bbox_inches='tight', dpi=1000)
    plt.draw()
    
''' ___________ Minor functions ____________________________________________'''

def dict_values_to_list(initial_dict, specified_keys):
    return list({ k: initial_dict[k] for k in specified_keys}.values())
    


